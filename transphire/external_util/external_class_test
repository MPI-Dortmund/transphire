"""
    TranSPHIRE is supposed to help with the cryo-EM data collection
    Copyright (C) 2017 Markus Stabrin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import re
import abc


def check_return(number, type_return, type_entry, return_value):
    if type_return is None:
        assert return_value is type_return
    else:
        assert isinstance(return_value, type_return)

    if number == 1:
        if type_entry is None:
            assert return_value is type_entry
        else:
            assert isinstance(return_value, type_entry)
    else:
        dtypes = []
        if isinstance(type_entry, list):
            dtypes.extend(type_entry)
        else:
            dtypes.extend([type_entry for _ in range(number)])
        assert len(dtypes) == number

        for value, entry in zip(return_value, dtypes):
            if entry is None:
                assert value is None
            else:
                assert isinstance(value, entry)


def check_instance(parent_instance=None):
    def check_arguments(func):
        def wrap(*args, **kwargs):
            self = args[0]
            func_name = args[1]
            func_args = args[2:]

            if parent_instance is not None:
                test_name = re.match(r'.*\.([^ ]+) .*', str(func)).group(1)
                method = getattr(parent_instance, test_name)
                number, type_return, type_entry = method(*func_args, **kwargs)

            return_value = func(self, static_args=func_args, static_kwargs=kwargs, name=func_name)

            if parent_instance is not None:
                check_return(
                    number=number,
                    type_return=type_return,
                    type_entry=type_entry,
                    return_value=return_value
                    )

            return return_value
        return wrap
    return check_arguments


class ExternalSoftwareBase(object):

    def __init__(self, function_dict):
        self.function_dict = function_dict

    @staticmethod
    @check_instance()
    def get_meta_info():
        pass

    @staticmethod
    @check_instance()
    def get_frames(compare_name, extension):
        pass

    @staticmethod
    @check_instance()
    def get_number_of_frames(frames, command, expected_frames):
        pass

    @staticmethod
    @check_instance()
    def get_meta_data(frames_root, root_name, extension):
        pass

    @staticmethod
    @check_instance()
    def get_command():
        pass


class ExternalClass(object):

    def __init__(self, function_dict):
        self.function_dict = function_dict

    def run_step(self, static_args, static_kwargs, name):
        return self.function_dict[name](*static_args, **static_kwargs)


class TemplateClass(ExternalSoftwareBase, ExternalClass):

    def __init__(self, function_dict):
        super(TemplateClass, self).__init__(function_dict=function_dict)
        self.function_dict = function_dict

    @check_instance(ExternalClass)
    def run_step(self, static_args, static_kwargs, name):
        return self.function_dict[name](*static_args, **static_kwargs)


if __name__ == '__main__':
    def test():
        print('hi')
    a = TemplateClass({'get_content': test})
    a.run_step('get_content')
